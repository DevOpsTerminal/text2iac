import { logger } from './logger';

export class MermaidGenerator {
  /**
   * Generates a Mermaid diagram from infrastructure analysis
   * @param analysis The analysis result from the LLM
   * @returns Mermaid diagram code
   */
  static generateArchitectureDiagram(analysis: any): string {
    try {
      if (!analysis || !analysis.components || !Array.isArray(analysis.components)) {
        throw new Error('Invalid analysis data');
      }

      const components = analysis.components || [];
      const relationships = analysis.relationships || [];
      const title = analysis.projectName || 'Infrastructure Architecture';

      // Start building the Mermaid diagram
      let diagram = '%% Generated by Text2IaC - Infrastructure Architecture Diagram\n';
      diagram += 'graph TD\n';
      diagram += `    %% Title: ${title}\n`;
      diagram += '    classDef default fill:#f9f,stroke:#333,stroke-width:2px;\n';
      diagram += '    classDef aws fill:#FF9900,stroke:#333,stroke-width:2px,color:#000;\n';
      diagram += '    classDef azure fill:#0078D4,stroke:#333,stroke-width:2px,color:#fff;\n';
      diagram += '    classDef gcp fill:#4285F4,stroke:#333,stroke-width:2px,color:#fff;\n';
      diagram += '    classDef db fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff;\n';
      diagram += '    classDef compute fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff;\n';
      diagram += '    classDef network fill:#9C27B0,stroke:#333,stroke-width:2px,color:#fff;\n';
      diagram += '    classDef storage fill:#FFC107,stroke:#333,stroke-width:2px,color:#000;\n\n';

      // Add nodes with appropriate styling based on component type
      components.forEach((component: string) => {
        const nodeId = this.sanitizeId(component);
        const nodeLabel = component;
        
        // Determine node style based on component type
        let styleClass = 'default';
        const lowerComponent = component.toLowerCase();
        
        // AWS components
        if (lowerComponent.includes('aws') || lowerComponent.includes('amazon') || lowerComponent.includes('s3') || lowerComponent.includes('ec2') || lowerComponent.includes('lambda')) {
          styleClass = 'aws';
        } 
        // Azure components
        else if (lowerComponent.includes('azure') || lowerComponent.includes('blob') || lowerComponent.includes('function') || lowerComponent.includes('app service')) {
          styleClass = 'azure';
        }
        // GCP components
        else if (lowerComponent.includes('gcp') || lowerComponent.includes('google') || lowerComponent.includes('cloud function') || lowerComponent.includes('cloud run')) {
          styleClass = 'gcp';
        }
        // Database components
        else if (lowerComponent.includes('db') || lowerComponent.includes('database') || lowerComponent.includes('postgres') || 
                 lowerComponent.includes('mysql') || lowerComponent.includes('mongo') || lowerComponent.includes('dynamo') || 
                 lowerComponent.includes('cosmos') || lowerComponent.includes('firestore')) {
          styleClass = 'db';
        }
        // Compute components
        else if (lowerComponent.includes('vm') || lowerComponent.includes('instance') || lowerComponent.includes('container') || 
                 lowerComponent.includes('pod') || lowerComponent.includes('function') || lowerComponent.includes('app')) {
          styleClass = 'compute';
        }
        // Network components
        else if (lowerComponent.includes('vpc') || lowerComponent.includes('network') || lowerComponent.includes('subnet') || 
                 lowerComponent.includes('load balancer') || lowerComponent.includes('api gateway') || lowerComponent.includes('ingress')) {
          styleClass = 'network';
        }
        // Storage components
        else if (lowerComponent.includes('storage') || lowerComponent.includes('bucket') || lowerComponent.includes('volume') || 
                 lowerComponent.includes('disk') || lowerComponent.includes('filesystem')) {
          styleClass = 'storage';
        }
        
        // Add node to diagram
        diagram += `    ${nodeId}[${nodeLabel}]:::${styleClass}\n`;
      });

      // Add relationships between components
      if (relationships && Array.isArray(relationships)) {
        diagram += '\n    %% Component Relationships\n';
        relationships.forEach((rel: any) => {
          const from = this.sanitizeId(rel.from);
          const to = this.sanitizeId(rel.to);
          const label = rel.label ? `|${rel.label}|` : '';
          const arrow = rel.direction === 'bidirectional' ? ' <--> ' : ' --> ';
          diagram += `    ${from} ${arrow} ${to} ${label}\n`;
        });
      } else {
        // If no explicit relationships, create a simple flow
        diagram += '\n    %% Default Flow\n';
        for (let i = 0; i < components.length - 1; i++) {
          const from = this.sanitizeId(components[i]);
          const to = this.sanitizeId(components[i + 1]);
          diagram += `    ${from} --> ${to}\n`;
        }
      }

      // Add legend if we have multiple styles
      const hasMultipleStyles = new Set(
        components.map(c => {
          const lower = c.toLowerCase();
          if (lower.includes('aws') || lower.includes('s3') || lower.includes('ec2')) return 'aws';
          if (lower.includes('azure') || lower.includes('blob')) return 'azure';
          if (lower.includes('gcp') || lower.includes('google')) return 'gcp';
          if (lower.includes('db') || lower.includes('database')) return 'db';
          return 'default';
        })
      ).size > 1;

      if (hasMultipleStyles) {
        diagram += '\n    %% Legend\n';
        diagram += '    subgraph Legend\n';
        diagram += '        direction TB\n';
        diagram += '        aws_legend[AWS]:::aws\n';
        diagram += '        azure_legend[Azure]:::azure\n';
        diagram += '        gcp_legend[GCP]:::gcp\n';
        diagram += '        db_legend[Database]:::db\n';
        diagram += '        compute_legend[Compute]:::compute\n';
        diagram += '        network_legend[Network]:::network\n';
        diagram += '        storage_legend[Storage]:::storage\n';
        diagram += '    end\n';
      }

      return diagram;
    } catch (error) {
      logger.error('Error generating Mermaid diagram:', error);
      
      // Return a simple error diagram
      return `graph TD
    Error[Error generating diagram]:::error
    classDef error fill:#ffebee,stroke:#f44336,stroke-width:2px,color:#b71c1c;`;
    }
  }

  /**
   * Sanitizes a string to be used as a Mermaid node ID
   */
  private static sanitizeId(str: string): string {
    return str
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '');
  }

  /**
   * Generates a sequence diagram for workflow visualization
   */
  static generateSequenceDiagram(workflow: any): string {
    try {
      if (!workflow || !workflow.steps || !Array.isArray(workflow.steps)) {
        throw new Error('Invalid workflow data');
      }

      let diagram = '%% Generated by Text2IaC - Workflow Sequence Diagram\n';
      diagram += 'sequenceDiagram\n';
      diagram += '    autonumber\n';
      diagram += `    title ${workflow.name || 'Workflow'}\n\n`;

      // Add participants
      const participants = new Set<string>();
      workflow.steps.forEach((step: any) => {
        if (step.actor) participants.add(step.actor);
        if (step.target) participants.add(step.target);
      });

      participants.forEach(participant => {
        diagram += `    participant ${this.sanitizeId(participant)} as ${participant}\n`;
      });

      diagram += '\n';

      // Add steps
      workflow.steps.forEach((step: any, index: number) => {
        const from = step.actor ? this.sanitizeId(step.actor) : 'unknown';
        const to = step.target ? this.sanitizeId(step.target) : 'unknown';
        const action = step.action || 'interacts with';
        const note = step.note ? `\n    Note over ${from},${to}: ${step.note}` : '';
        
        diagram += `    ${from}->>${to}: ${action}${note}\n`;
        
        if (step.wait) {
          diagram += `    ${to}-->>${from}: Processing...\n`;
          diagram += `    ${to}->>${from}: Completed\n`;
        }
      });

      return diagram;
    } catch (error) {
      logger.error('Error generating sequence diagram:', error);
      return `sequenceDiagram
    participant Error
    Note over Error: Error generating sequence diagram: ${error.message}`;
    }
  }

  /**
   * Generates a state diagram for state machine visualization
   */
  static generateStateDiagram(states: any): string {
    try {
      if (!states || !Array.isArray(states) || states.length === 0) {
        throw new Error('Invalid states data');
      }

      let diagram = '%% Generated by Text2IaC - State Diagram\n';
      diagram += 'stateDiagram-v2\n';
      diagram += '    [*] --> ' + this.sanitizeId(states[0].name) + '\n';

      states.forEach((state: any) => {
        const stateId = this.sanitizeId(state.name);
        
        // Add state with optional description
        if (state.description) {
          diagram += `    state "${state.name}" as ${stateId} : ${state.description}\n`;
        } else {
          diagram += `    ${stateId}: ${state.name}\n`;
        }
        
        // Add transitions
        if (state.transitions && Array.isArray(state.transitions)) {
          state.transitions.forEach((transition: any) => {
            const targetId = this.sanitizeId(transition.target);
            const event = transition.event || '';
            const condition = transition.condition ? `[${transition.condition}]` : '';
            diagram += `    ${stateId} --> ${targetId}: ${event} ${condition}\n`;
          });
        }
      });

      // Add final state if specified
      const finalState = states.find((s: any) => s.final);
      if (finalState) {
        diagram += `    ${this.sanitizeId(finalState.name)} --> [*]\n`;
      }

      return diagram;
    } catch (error) {
      logger.error('Error generating state diagram:', error);
      return `stateDiagram-v2
    [*] --> Error
    Error: ${error.message}`;
    }
  }
}
